// Generated by CoffeeScript 2.1.1
// Require Node.js core modules.
var VERSION, config, configPath, emptyHeaders, endParams, endReqOpts, flush, fs, http, https, httpsPattern, log, pixel, pixelHeaders, protocol, protocolOptions, querystring, record, reset, serialize, server, store, url;

fs = require('fs');

url = require('url');

http = require('http');

https = require('https');

querystring = require('querystring');

//### The Pixel Ping server

// Keep the version number in sync with `package.json`.
VERSION = '0.1.4';

// Regular expression for HTTPS addresses
httpsPattern = new RegExp('^https://', 'i');

store = {};

// Record a single incoming hit from the remote pixel.
record = function(params) {
  var hitDate, node, nodeID, ref, separator;
  // Get node ID from path.
  if (!(nodeID = (ref = params.pathname) != null ? ref.split('/')[2] : void 0)) {
    return;
  }
  separator = '^';
  // Truncate timestamp to 10 digits so Drupal doesn't overflow.
  hitDate = Date.now().toString().substr(0, 10);
  node = hitDate + separator + params.remoteAddress + separator + params.domain + separator + params.referrerPath + separator + nodeID;
  store[node] || (store[node] = 0);
  return store[node] += 1;
};

// Serializes the current `store` to JSON, and creates a fresh one. Add a
// `secret` token to the request object, if configured.
serialize = function() {
  var data;
  data = {
    json: JSON.stringify(store)
  };
  if (config.secret) {
    data.secret = config.secret;
  }
  return querystring.stringify(data);
};

// Reset the `store`.
reset = function() {
  return store = {};
};

// Flushes the `store` to be saved by an external API. The contents of the store
// are sent to the configured `endpoint` URL via HTTP/HTTPS POST. If no `endpoint` is
// configured, this is a no-op.
flush = function() {
  var data, endpointProtocol, request;
  log(store);
  if (!config.endpoint) {
    return;
  } else if (httpsPattern.test(config.endpoint)) {
    endpointProtocol = https;
  } else {
    endpointProtocol = http;
  }
  data = serialize();
  endReqOpts['headers']['Content-Length'] = data.length;
  request = endpointProtocol.request(endReqOpts, function(response) {
    reset();
    return console.info('--- flushed ---');
  });
  request.on('error', function(e) {
    if (config.discard) {
      reset();
    }
    return console.log(`--- cannot connect to endpoint : ${e.message}`);
  });
  request.write(data);
  return request.end();
};

// Log the contents of the `store` to **stdout**. Happens on every flush, so that
// there's a record of hits if something goes awry.
log = function(hash) {
  var hits, node, results;
  results = [];
  for (node in hash) {
    hits = hash[node];
    results.push(console.info(`${hits}:\t${node}`));
  }
  return results;
};

//### Configuration

// Load the configuration and the contents of the tracking pixel. Handle requests
// for the version number, and usage information.
configPath = process.argv[2];

if (configPath === '-v' || configPath === '-version' || configPath === '--version') {
  console.log(`Pixel Ping version ${VERSION}`);
  process.exit(0);
}

if (!configPath || (configPath === '-h' || configPath === '-help' || configPath === '--help')) {
  console.error("Usage: pixel-ping path/to/config.json");
  process.exit(0);
}

config = JSON.parse(fs.readFileSync(configPath).toString());

pixel = fs.readFileSync(__dirname + '/pixel.gif');

// HTTP/HTTPS headers for the pixel image.
pixelHeaders = {
  'Cache-Control': 'private, no-cache, proxy-revalidate, max-age=0',
  'Content-Type': 'image/gif',
  'Content-Disposition': 'inline',
  'Content-Length': pixel.length
};

// HTTP/HTTPS headers for the 404 response.
emptyHeaders = {
  'Content-Type': 'text/html',
  'Content-Length': '0'
};

// If an `endpoint` has been configured, create an HTTP/HTTPS client connected to it,
// and log a warning otherwise.
if (config.endpoint) {
  console.info(`Flushing hits to ${config.endpoint}`);
  endParams = url.parse(config.endpoint);
  endReqOpts = {
    host: endParams.hostname,
    port: endParams.port || 80,
    method: 'POST',
    path: endParams.pathname,
    headers: {
      'host': endParams.host,
      'Content-Type': 'application/x-www-form-urlencoded'
    }
  };
} else {
  console.warn(`No endpoint set. Hits won't be flushed, add "endpoint" to ${configPath}.`);
}

// Sending `SIGUSR2` to the Pixel Ping process will force a data flush.
process.on('SIGUSR2', function() {
  console.log('Got SIGUSR2. Forcing a flush:');
  return flush();
});

// Don't let exceptions kill the server.
process.on('uncaughtException', function(err) {
  return console.error(`Uncaught Exception: ${err}`);
});

// Determines the right protocol (HTTP/HTTPS) to be used on the nodejs server
if (config.sslkey && config.sslcert && config.sslca) {
  protocol = https;
  protocolOptions = {
    key: fs.readFileSync(config.sslkey),
    cert: fs.readFileSync(config.sslcert),
    ca: fs.readFileSync(config.sslca)
  };
} else if (config.sslkey && config.sslcert) {
  protocol = https;
  protocolOptions = {
    key: fs.readFileSync(config.sslkey),
    cert: fs.readFileSync(config.sslcert)
  };
} else {
  protocol = http;
}

server = protocol.createServer(protocolOptions, function(req, res) {
  var allElements, domain, lastElement, params, referrerPath, urlParts;
  params = url.parse(req.url, true, true);
  allElements = params.pathname.split('/');
  lastElement = allElements[allElements.length - 1];
  if (lastElement === 'count.gif') {
    params["remoteAddress"] = req.connection.remoteAddress;
    urlParts = req.headers.referer.split('/');
    domain = urlParts[0] + '//' + urlParts[2];
    params["domain"] = domain;
    referrerPath = urlParts;
    referrerPath.shift();
    referrerPath.shift();
    referrerPath.shift();
    referrerPath = referrerPath.join('/');
    params["referrerPath"] = '/' + referrerPath;
    res.writeHead(200, pixelHeaders);
    res.end(pixel);
    record(params);
  } else {
    res.writeHead(404, emptyHeaders);
    res.end('');
  }
  return null;
});

//### Startup

// Start the server listening for pixel hits, and begin the periodic data flush.
server.listen(config.port, config.host);

setInterval(flush, config.interval * 1000);
